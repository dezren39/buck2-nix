#! /usr/bin/env bash
# SPDX-FileCopyrightText: Â© 2022 Austin Seipp
# SPDX-License-Identifier: MIT OR Apache-2.0

set -e
set -o pipefail

# NOTE: you should occasionally do this from a shell:
#
#     $ nix run nixpkgs#shellcheck -- ./buck/nix/update.sh

FLAKE=0
TOOLCHAINS=0
CACHE=0

usage() {
  echo "Usage: $0 [--flake|--toolchains|--cache|--all]"
  exit 2
}

PARSED_ARGUMENTS=$(getopt -an update.sh -o ftca --long flake,toolchains,cache,all -- "$@")
VALID_ARGUMENTS=$?
[ "$VALID_ARGUMENTS" != "0" ] && usage

eval set -- "$PARSED_ARGUMENTS"
while : ; do
  case "$1" in
    -f | --flake)      FLAKE=1      ; shift ;;
    -t | --toolchains) TOOLCHAINS=1 ; shift ;;
    -c | --cache)      CACHE=1      ; shift ;;
    -a | --all)        FLAKE=1; TOOLCHAINS=1; CACHE=1; shift ;;

    --) shift; break ;;
    *) echo "Unexpected option: $1 - this should not happen." && usage ;;
  esac
done

[ "$FLAKE" = "0" ] && [ "$TOOLCHAINS" = "0" ] && [ "$CACHE" = "0" ] && usage
echo "Updating flake: $FLAKE, toolchains: $TOOLCHAINS, cache: $CACHE"

if [ "$FLAKE" = "1" ]; then
  root=$(sl root)
  nix flake update "${root}/buck/nix"
fi

if [ "$TOOLCHAINS" = "1" ]; then
  root=$(sl root)
  nix build --accept-flake-config --print-out-paths "${root}/buck/nix#world"

  set -x

  # Build the Buck dependency graph for all Nix paths
  (cat <<EOF
# SPDX-License-Identifier: MIT OR Apache-2.0

# NOTE: DO NOT EDIT MANUALLY!
# NOTE: This file is @generated by the following command:
#
#    buck run nix//:update -- -t
#
# NOTE: Please run the above command to regenerate this file.

load("@prelude//:nix.bzl", "nix")

EOF
  ) > "${root}/buck/nix/toolchains/TARGETS"

  depgraph="${root}/buck/nix/toolchains/depgraph.json"
  jq -r '.toolchainPackages | to_entries[] | .value' ./result \
    | xargs nix path-info -r --json \
    | jq '.[] | with_entries(select([.key] | inside(["path","deriver","references"]))) | { (.path[11:]): { "d": .deriver[11:], "r": (.references - [.path])  | map(.[11:]) } }' \
    | jq -n 'reduce inputs as $in (null; . + $in)' \
    > "$depgraph"

  jq -r '.toolchainPackages | to_entries[] | [ .key, .value ] | join(" ")' ./result \
    | while read -r name out; do
        dat=$(jq -r ".[\"${out:11}\"]" < "$depgraph")
        d=$(echo "$dat" | jq -r '.d')

        cat << EOF
nix.toolchain(
  name = "${name}",
  hash = "${out:11}",
  path = ":${out:11}",
  drv = "${d:11}",
  visibility = ["PUBLIC"],
)

EOF
      done \
    >> "${root}/buck/nix/toolchains/TARGETS"

  jq -r 'to_entries[] | .key' < "$depgraph" \
    | while read -r path; do
        dat=$(jq -r ".[\"${path}\"]" < "$depgraph")
        d=$(echo "$dat" | jq -r '.d')
        r=$(echo "$dat" | jq --indent 4 -r '.r | map(":\(.)")' | sed 's/^\]/  \]/')
        cat << EOF
nix.store_path(
  name = "${path}",
  drv = "${d}",
  refs = ${r},
)

EOF
      done \
    >> "${root}/buck/nix/toolchains/TARGETS"
  rm "$depgraph"
  rm ./result*
fi

if [ "$CACHE" = "1" ]; then
  MANUAL_REBUILD_AND_PUSH=1 "$(sl root)/buck/nix/cache-upload.sh"
fi
